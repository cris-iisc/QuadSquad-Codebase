#define BOOST_TEST_MODULE sharing

#include <quadsquad/sharing.h>
#include <quadsquad/types.h>

#include <boost/test/data/monomorphic.hpp>
#include <boost/test/data/test_case.hpp>
#include <boost/test/included/unit_test.hpp>
#include <random>
#include <vector>

using namespace quadsquad;
namespace bdata = boost::unit_test::data;

constexpr int TEST_DATA_MAX_VAL = 1000;
constexpr int NUM_SAMPLES = 1;

// Utility function to generate replicated secret sharing of 3 parties.
std::vector<ReplicatedShare<Ring>> generateReplicatedShares(Ring secret) {
  std::random_device rd;
  std::mt19937 engine(rd());
  std::uniform_int_distribution<Ring> distrib;

  std::vector<Ring> share_elements(6);
  Ring sum = 0;
  for (int i = 0; i < 5; ++i) {
    share_elements[i] = distrib(engine);
    sum += share_elements[i];
  }
  share_elements[5] = secret - sum;

  return {
      ReplicatedShare<Ring>{
          {share_elements[0], share_elements[1], share_elements[2]}},
      ReplicatedShare<Ring>{
          {share_elements[3], share_elements[4], share_elements[0]}},
      ReplicatedShare<Ring>{
          {share_elements[5], share_elements[1], share_elements[3]}},
  };
}

// Utility function to reconstruct secret from shares as generated by
// generateReplicatedShares function.
Ring reconstructReplicatedShares(
    const std::vector<ReplicatedShare<Ring>>& v_rss) {
  return v_rss[0].sum() + v_rss[1][0] + v_rss[1][1] + v_rss[2][0];
}

BOOST_AUTO_TEST_SUITE(replicated_sharing)

BOOST_DATA_TEST_CASE(reconstruction,
                     bdata::random(0, TEST_DATA_MAX_VAL) ^
                         bdata::xrange(NUM_SAMPLES),
                     secret_val, idx) {
  Ring secret = secret_val;
  auto v_rss = generateReplicatedShares(secret);
  auto recon_value = reconstructReplicatedShares(v_rss);
  BOOST_TEST(recon_value == secret);
}

BOOST_DATA_TEST_CASE(share_arithmetic,
                     bdata::random(0, TEST_DATA_MAX_VAL) ^
                         bdata::random(0, TEST_DATA_MAX_VAL) ^
                         bdata::xrange(NUM_SAMPLES),
                     vala, valb, idx) {
  Ring a = vala;
  Ring b = valb;
  auto v_rss_a = generateReplicatedShares(a);
  auto v_rss_b = generateReplicatedShares(b);

  std::vector<ReplicatedShare<Ring>> v_rss_c(v_rss_a.size());
  for (size_t i = 0; i < v_rss_c.size(); ++i) {
    // This implicitly checks compound assignment operators too.
    v_rss_c[i] = v_rss_a[i] + v_rss_b[i];
  }

  auto sum = reconstructReplicatedShares(v_rss_c);
  BOOST_TEST(sum == a + b);

  for (size_t i = 0; i < v_rss_c.size(); ++i) {
    // This implicitly checks compound assignment operators too.
    v_rss_c[i] = v_rss_a[i] - v_rss_b[i];
  }

  auto difference = reconstructReplicatedShares(v_rss_c);
  BOOST_TEST(difference == a - b);
}

BOOST_DATA_TEST_CASE(share_const_arithmetic,
                     bdata::random(0, TEST_DATA_MAX_VAL) ^
                         bdata::random(0, TEST_DATA_MAX_VAL) ^
                         bdata::xrange(NUM_SAMPLES),
                     secret_val, const_val, idx) {
  Ring secret = secret_val;
  Ring constant = const_val;
  auto v_rss = generateReplicatedShares(secret);

  std::vector<ReplicatedShare<Ring>> v_rss_res(v_rss.size());
  for (size_t i = 0; i < v_rss_res.size(); ++i) {
    // This implicitly checks compound assignment operators too.
    v_rss_res[i] = v_rss[i] * constant;
  }

  auto product = reconstructReplicatedShares(v_rss_res);
  BOOST_TEST(product == secret * constant);
}

BOOST_AUTO_TEST_SUITE_END()
